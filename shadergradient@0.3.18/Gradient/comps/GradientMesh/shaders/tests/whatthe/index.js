// src/Gradient/comps/GradientMesh/shaders/tests/whatthe/fragment.glsl
var fragment_default = "\n#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\n#define SQRT2_MINUS_ONE 0.41421356\n#define SQRT2_HALF_MINUS_ONE 0.20710678\n#define SHAPE_DOT 1\n#define SHAPE_ELLIPSE 2\n#define SHAPE_LINE 3\n#define SHAPE_SQUARE 4\n#define BLENDING_LINEAR 1\n#define BLENDING_MULTIPLY 2\n#define BLENDING_ADD 3\n#define BLENDING_LIGHTER 4\n#define BLENDING_DARKER 5\nuniform sampler2D tDiffuse;uniform float radius;uniform float rotateR;uniform float rotateG;uniform float rotateB;uniform float scatter;uniform float width;uniform float height;uniform int shape;uniform bool disable;uniform float blending;uniform int blendingMode;varying vec2 vUv;uniform bool greyscale;const int samples=8;uniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;varying vec3 vBitangent;\n#endif\n#endif\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <color_pars_fragment>\n#include <common>\n#include <dithering_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <map_pars_fragment>\n#include <packing>\n#include <uv2_pars_fragment>\n#include <uv_pars_fragment>\n#include <bsdfs>\n#include <bumpmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <shadowmap_pars_fragment>\nvarying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;uniform float uC1r;uniform float uC1g;uniform float uC1b;uniform float uC2r;uniform float uC2g;uniform float uC2b;uniform float uC3r;uniform float uC3g;uniform float uC3b;varying vec3 color1;varying vec3 color2;varying vec3 color3;float blend(float a,float b,float t){return a*(1.0-t)+b*t;}float hypot(float x,float y){return sqrt(x*x+y*y);}float distanceToDotRadius(float channel,vec2 coord,vec2 normal,vec2 p,float angle,float rad_max){float dist=hypot(coord.x-p.x,coord.y-p.y);float rad=channel;if(shape==SHAPE_DOT){rad=pow(abs(rad),1.125)*rad_max;}else if(shape==SHAPE_ELLIPSE){rad=pow(abs(rad),1.125)*rad_max;if(dist!=0.0){float dot_p=abs((p.x-coord.x)/dist*normal.x+(p.y-coord.y)/dist*normal.y);dist=(dist*(1.0-SQRT2_HALF_MINUS_ONE))+dot_p*dist*SQRT2_MINUS_ONE;}}else if(shape==SHAPE_LINE){rad=pow(abs(rad),1.5)*rad_max;float dot_p=(p.x-coord.x)*normal.x+(p.y-coord.y)*normal.y;dist=hypot(normal.x*dot_p,normal.y*dot_p);}else if(shape==SHAPE_SQUARE){float theta=atan(p.y-coord.y,p.x-coord.x)-angle;float sin_t=abs(sin(theta));float cos_t=abs(cos(theta));rad=pow(abs(rad),1.4);rad=rad_max*(rad+((sin_t>cos_t)?rad-sin_t*rad:rad-cos_t*rad));}return rad-dist;}struct Cell{vec2 normal;vec2 p1;vec2 p2;vec2 p3;vec2 p4;float samp2;float samp1;float samp3;float samp4;};vec4 getSample(vec2 point){vec4 tex=texture2D(tDiffuse,vec2(point.x/width,point.y/height));float base=rand(vec2(floor(point.x),floor(point.y)))*PI2;float step=PI2/float(samples);float dist=radius*0.66;for(int i=0;i<samples;++i){float r=base+step*float(i);vec2 coord=point+vec2(cos(r)*dist,sin(r)*dist);tex+=texture2D(tDiffuse,vec2(coord.x/width,coord.y/height));}tex/=float(samples)+1.0;return tex;}float getDotColour(Cell c,vec2 p,int channel,float angle,float aa){float dist_c_1,dist_c_2,dist_c_3,dist_c_4,res;if(channel==0){c.samp1=getSample(c.p1).r;c.samp2=getSample(c.p2).r;c.samp3=getSample(c.p3).r;c.samp4=getSample(c.p4).r;}else if(channel==1){c.samp1=getSample(c.p1).g;c.samp2=getSample(c.p2).g;c.samp3=getSample(c.p3).g;c.samp4=getSample(c.p4).g;}else{c.samp1=getSample(c.p1).b;c.samp3=getSample(c.p3).b;c.samp2=getSample(c.p2).b;c.samp4=getSample(c.p4).b;}dist_c_1=distanceToDotRadius(c.samp1,c.p1,c.normal,p,angle,radius);dist_c_2=distanceToDotRadius(c.samp2,c.p2,c.normal,p,angle,radius);dist_c_3=distanceToDotRadius(c.samp3,c.p3,c.normal,p,angle,radius);dist_c_4=distanceToDotRadius(c.samp4,c.p4,c.normal,p,angle,radius);res=(dist_c_1>0.0)?clamp(dist_c_1/aa,0.0,1.0):0.0;res+=(dist_c_2>0.0)?clamp(dist_c_2/aa,0.0,1.0):0.0;res+=(dist_c_3>0.0)?clamp(dist_c_3/aa,0.0,1.0):0.0;res+=(dist_c_4>0.0)?clamp(dist_c_4/aa,0.0,1.0):0.0;res=clamp(res,0.0,1.0);return res;}Cell getReferenceCell(vec2 p,vec2 origin,float grid_angle,float step){Cell c;vec2 n=vec2(cos(grid_angle),sin(grid_angle));float threshold=step*0.5;float dot_normal=n.x*(p.x-origin.x)+n.y*(p.y-origin.y);float dot_line=-n.y*(p.x-origin.x)+n.x*(p.y-origin.y);vec2 offset=vec2(n.x*dot_normal,n.y*dot_normal);float offset_normal=mod(hypot(offset.x,offset.y),step);float normal_dir=(dot_normal<0.0)?1.0:-1.0;float normal_scale=((offset_normal<threshold)?-offset_normal:step-offset_normal)*normal_dir;float offset_line=mod(hypot((p.x-offset.x)-origin.x,(p.y-offset.y)-origin.y),step);float line_dir=(dot_line<0.0)?1.0:-1.0;float line_scale=((offset_line<threshold)?-offset_line:step-offset_line)*line_dir;c.normal=n;c.p1.x=p.x-n.x*normal_scale+n.y*line_scale;c.p1.y=p.y-n.y*normal_scale-n.x*line_scale;if(scatter!=0.0){float off_mag=scatter*threshold*0.5;float off_angle=rand(vec2(floor(c.p1.x),floor(c.p1.y)))*PI2;c.p1.x+=cos(off_angle)*off_mag;c.p1.y+=sin(off_angle)*off_mag;}float normal_step=normal_dir*((offset_normal<threshold)?step:-step);float line_step=line_dir*((offset_line<threshold)?step:-step);c.p2.x=c.p1.x-n.x*normal_step;c.p2.y=c.p1.y-n.y*normal_step;c.p3.x=c.p1.x+n.y*line_step;c.p3.y=c.p1.y-n.x*line_step;c.p4.x=c.p1.x-n.x*normal_step+n.y*line_step;c.p4.y=c.p1.y-n.y*normal_step-n.x*line_step;return c;}float blendColour(float a,float b,float t){if(blendingMode==BLENDING_LINEAR){return blend(a,b,1.0-t);}else if(blendingMode==BLENDING_ADD){return blend(a,min(1.0,a+b),t);}else if(blendingMode==BLENDING_MULTIPLY){return blend(a,max(0.0,a*b),t);}else if(blendingMode==BLENDING_LIGHTER){return blend(a,max(a,b),t);}else if(blendingMode==BLENDING_DARKER){return blend(a,min(a,b),t);}else{return blend(a,b,1.0-t);}}void main(){vec3 color1=vec3(uC1r,uC1g,uC1b);vec3 color2=vec3(uC2r,uC2g,uC2b);vec3 color3=vec3(uC3r,uC3g,uC3b);float clearcoat=1.0;float clearcoatRoughness=0.5;\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(mix(mix(color1,color2,smoothstep(-3.0,3.0,vPos.x)),color3,vPos.z),1);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#ifdef TRANSMISSION\nfloat totalTransmission=transmission;\n#endif\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular;\n#ifdef TRANSMISSION\ndiffuseColor.a*=mix(saturate(1.-totalTransmission+linearToRelativeLuminance(reflectedLight.directSpecular+reflectedLight.indirectSpecular)),1.0,metalness);\n#endif\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\nvec2 p=vec2(vUv.x*width,vUv.y*height);vec2 origin=vec2(0,0);float aa=(radius<2.5)?radius*0.5:1.25;Cell cell_r=getReferenceCell(p,origin,rotateR,radius);Cell cell_g=getReferenceCell(p,origin,rotateG,radius);Cell cell_b=getReferenceCell(p,origin,rotateB,radius);float r=getDotColour(cell_r,p,0,rotateR,aa);float g=getDotColour(cell_g,p,1,rotateG,aa);float b=getDotColour(cell_b,p,2,rotateB,aa);vec4 colour=texture2D(tDiffuse,vUv);r=blendColour(r,colour.r,blending);g=blendColour(g,colour.g,blending);b=blendColour(b,colour.b,blending);vec3 grainColor=mix(vec3(r,g,b),outgoingLight,0.4);gl_FragColor=vec4(grainColor,diffuseColor.a);}";

// src/Gradient/comps/GradientMesh/shaders/tests/whatthe/vertex.glsl
var vertex_default = "#pragma glslify: cnoise3 = require(glsl-noise/classic/3d)\nmat3 rotation3dY(float angle){float s=sin(angle);float c=cos(angle);return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);}vec3 rotateY(vec3 v,float angle){return rotation3dY(angle)*v;}varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;varying vec2 vUv;uniform float uTime;uniform float uSpeed;uniform float uNoiseDensity;uniform float uNoiseStrength;\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n#ifdef USE_TANGENT\nvarying vec3 vTangent;varying vec3 vBitangent;\n#endif\n#endif\n#include <clipping_planes_pars_vertex>\n#include <color_pars_vertex>\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <skinning_pars_vertex>\n#include <uv2_pars_vertex>\n#include <uv_pars_vertex>\nvoid main(){\n#include <beginnormal_vertex>\n#include <color_vertex>\n#include <defaultnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <uv2_vertex>\n#include <uv_vertex>\n#ifndef FLAT_SHADED\nvNormal=normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);\n#endif\n#endif\n#include <begin_vertex>\n#include <clipping_planes_vertex>\n#include <displacementmap_vertex>\n#include <logdepthbuf_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\n#include <skinning_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <fog_vertex>\n#include <shadowmap_vertex>\n#include <worldpos_vertex>\nvUv=uv;float t=uTime*uSpeed;float distortion=0.75*cnoise3(0.43*position*uNoiseDensity+t);vec3 pos=position+normal*distortion*uNoiseStrength;vPos=pos;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);}";
export {
  fragment_default as fragment,
  vertex_default as vertex
};
